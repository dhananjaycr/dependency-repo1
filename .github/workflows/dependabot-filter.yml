name: Dependabot PR Filter

on:
  pull_request:
    types: [opened, reopened]

jobs:
  filter-dependabot-pr:
    if: github.actor == 'dependabot[bot]'
    runs-on: ubuntu-latest
    permissions:
      pull-requests: write
      contents: read
      issues: write
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v3
        with:
          fetch-depth: 0
      
      - name: Setup Python
        uses: actions/setup-python@v4
        with:
          python-version: '3.9'
      
      - name: Setup Node.js
        uses: actions/setup-node@v3
        with:
          node-version: '18'
      
      - name: Install dependencies
        run: |
          pip install requests packaging
          npm install -g semver
      
      - name: Analyze Dependabot PR
        id: analyze
        uses: actions/github-script@v6
        with:
          script: |
            const fs = require('fs');
            const { execSync } = require('child_process');
            
            // Get PR details
            const pr = context.payload.pull_request;
            const title = pr.title;
            const body = pr.body || '';
            
            console.log('PR Title:', title);
            console.log('PR Body:', body);
            
            // Parse package name and versions from PR title
            // Dependabot PR titles follow pattern: "Bump <package> from <old> to <new> in <directory>"
            const bumpRegex = /Bump (.+) from (.+) to (.+) in (.+)/i;
            const match = title.match(bumpRegex);
            
            if (!match) {
              console.log('Could not parse PR title format');
              return { shouldClose: false, reason: 'Unable to parse PR format' };
            }
            
            const [, packageName, currentVersion, targetVersion, directory] = match;
            console.log('Package:', packageName);
            console.log('Current Version:', currentVersion);
            console.log('Target Version:', targetVersion);
            console.log('Directory:', directory);
            
            // Check if this is a security update
            const isSecurityUpdate = body.includes('security') || 
                                     body.includes('vulnerability') || 
                                     body.includes('CVE-') ||
                                     pr.labels.some(label => label.name === 'security');
            
            if (isSecurityUpdate) {
              console.log('âœ… Security update detected - allowing PR');
              await github.rest.issues.addLabels({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: pr.number,
                labels: ['security-critical', 'auto-approved']
              });
              return { shouldClose: false, reason: 'Security update - approved' };
            }
            
            // Determine package ecosystem
            const isPython = directory.includes('backend') || title.includes('.txt');
            const isNpm = directory.includes('frontend') || directory.includes('package.json');
            
            let releasesBehind = 0;
            let isLatestRelease = false;
            
            if (isPython) {
              console.log('Checking PyPI releases...');
              try {
                // Use Python script to check PyPI
                const pythonScript = `
import sys
import requests
from packaging import version as pkg_version

package = "${packageName}"
current = "${currentVersion}"
target = "${targetVersion}"

try:
    resp = requests.get(f"https://pypi.org/pypi/{package}/json", timeout=10)
    data = resp.json()
    
    # Get all stable releases (filter out pre-releases)
    all_versions = list(data["releases"].keys())
    stable_versions = [
        v for v in all_versions 
        if not any(x in v.lower() for x in ['a', 'b', 'rc', 'dev', 'alpha', 'beta'])
    ]
    
    # Sort versions
    stable_versions.sort(key=lambda x: pkg_version.parse(x))
    
    if current in stable_versions:
        current_idx = stable_versions.index(current)
        releases_behind = len(stable_versions) - current_idx - 1
        latest_version = stable_versions[-1]
        is_latest = (target == latest_version)
        
        print(f"{releases_behind}|{is_latest}")
    else:
        print("0|False")
except Exception as e:
    print(f"ERROR: {e}", file=sys.stderr)
    print("0|False")
`;
                
                fs.writeFileSync('/tmp/check_version.py', pythonScript);
                const result = execSync('python /tmp/check_version.py', { encoding: 'utf-8' }).trim();
                console.log('Python check result:', result);
                
                if (!result.includes('ERROR')) {
                  const [behind, isLatest] = result.split('|');
                  releasesBehind = parseInt(behind);
                  isLatestRelease = isLatest === 'True';
                }
              } catch (error) {
                console.error('Error checking PyPI:', error.message);
              }
            } else if (isNpm) {
              console.log('Checking npm releases...');
              try {
                // Check npm registry
                const response = await fetch(`https://registry.npmjs.org/${packageName}`);
                const data = await response.json();
                
                if (data.versions) {
                  const versions = Object.keys(data.versions).filter(v => {
                    // Filter out pre-releases
                    return !/alpha|beta|rc|pre|dev/i.test(v);
                  });
                  
                  // Sort versions using semver
                  const semver = require('semver');
                  const sortedVersions = versions.sort(semver.compare);
                  
                  const currentIdx = sortedVersions.indexOf(currentVersion);
                  if (currentIdx >= 0) {
                    releasesBehind = sortedVersions.length - currentIdx - 1;
                    const latestVersion = sortedVersions[sortedVersions.length - 1];
                    isLatestRelease = (targetVersion === latestVersion);
                  }
                  
                  console.log('Releases behind:', releasesBehind);
                  console.log('Is latest release:', isLatestRelease);
                }
              } catch (error) {
                console.error('Error checking npm:', error.message);
              }
            }
            
            // Apply version policy rules
            let shouldClose = false;
            let reason = '';
            
            // Rule 1: Only update if >3 releases behind
            if (releasesBehind <= 3) {
              shouldClose = true;
              reason = `Only ${releasesBehind} releases behind (policy requires >3 releases behind)`;
            }
            
            // Rule 2: Skip most recent production release (unless security-critical)
            if (isLatestRelease && !isSecurityUpdate) {
              shouldClose = true;
              reason = `Target is the latest release (policy skips most recent unless security-critical)`;
            }
            
            console.log('Decision:', shouldClose ? 'CLOSE' : 'ALLOW');
            console.log('Reason:', reason);
            
            return { shouldClose, reason, releasesBehind, isLatestRelease };
      
      - name: Close PR if policy not met
        if: steps.analyze.outputs.shouldClose == 'true'
        uses: actions/github-script@v6
        with:
          script: |
            const reason = '${{ steps.analyze.outputs.reason }}';
            const pr = context.payload.pull_request;
            
            // Add comment explaining why PR is closed
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `ðŸ¤– **Dependabot Version Policy Check**\n\n` +
                    `This PR has been automatically closed because:\n\n` +
                    `âŒ ${reason}\n\n` +
                    `**Our Version Policy:**\n` +
                    `- âœ… Updates are created only if >3 releases behind stable\n` +
                    `- âœ… Skip upgrades to the most recent production release\n` +
                    `- âœ… Exception: Security-critical updates are always allowed\n\n` +
                    `If this is a security update, please add the \`security\` label and reopen.`
            });
            
            // Add label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['policy-rejected']
            });
            
            // Close the PR
            await github.rest.pulls.update({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: pr.number,
              state: 'closed'
            });
      
      - name: Approve PR if policy met
        if: steps.analyze.outputs.shouldClose == 'false'
        uses: actions/github-script@v6
        with:
          script: |
            const pr = context.payload.pull_request;
            const reason = '${{ steps.analyze.outputs.reason }}';
            
            // Add approval comment
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              body: `âœ… **Dependabot Version Policy Check: PASSED**\n\n` +
                    `${reason}\n\n` +
                    `This PR meets our version policy requirements and is ready for review.`
            });
            
            // Add label
            await github.rest.issues.addLabels({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: pr.number,
              labels: ['policy-approved', 'ready-for-review']
            });

